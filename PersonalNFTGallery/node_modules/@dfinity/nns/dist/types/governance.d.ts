import { Principal } from "@dfinity/principal";
import { ICP } from "./icp";
import { LedgerCanister } from "./ledger";
import { E8s, NeuronId } from "./types/common";
import { GovernanceCanisterOptions } from "./types/governance";
import { ClaimOrRefreshNeuronRequest, FollowRequest, KnownNeuron, ListProposalsRequest, ListProposalsResponse, MakeProposalRequest, NeuronInfo, ProposalId, ProposalInfo, Vote } from "./types/governance_converters";
export declare class GovernanceCanister {
    private readonly canisterId;
    private readonly service;
    private readonly certifiedService;
    private readonly agent;
    private readonly hardwareWallet;
    private constructor();
    static create(options?: GovernanceCanisterOptions): GovernanceCanister;
    /**
     * Returns the list of neurons controlled by the caller.
     *
     * If an array of neuron IDs is provided, precisely those neurons will be fetched.
     *
     * If `certified` is true, the request is fetched as an update call, otherwise
     * it is fetched using a query call.
     *
     */
    listNeurons: ({ certified, neuronIds, }: {
        certified: boolean;
        neuronIds?: bigint[] | undefined;
    }) => Promise<NeuronInfo[]>;
    /**
     * Returns the list of neurons who have been approved by the community to
     * appear as the default followee options.
     *
     * If `certified` is true, the request is fetched as an update call, otherwise
     * it is fetched using a query call.
     */
    listKnownNeurons: (certified?: boolean) => Promise<KnownNeuron[]>;
    /**
     * Returns the list of proposals made for the community to vote on,
     * paginated and filtered by the request.
     *
     * If `certified` is true (default), the request is fetched as an update call, otherwise
     * it is fetched using a query call.
     */
    listProposals: ({ request, certified, }: {
        request: ListProposalsRequest;
        certified?: boolean | undefined;
    }) => Promise<ListProposalsResponse>;
    /**
     * @throws {@link InsufficientAmountError}
     * @throws {@link StakeNeuronTransferError}
     * @throws {@link CouldNotClaimNeuronError}
     * @throws {@link TransferError}
     */
    stakeNeuron: ({ stake, principal, fromSubAccount, ledgerCanister, }: {
        stake: ICP;
        principal: Principal;
        fromSubAccount?: number[] | undefined;
        ledgerCanister: LedgerCanister;
    }) => Promise<NeuronId>;
    /**
     * Increases dissolve delay of a neuron
     *
     * @throws {@link GovernanceError}
     */
    increaseDissolveDelay: ({ neuronId, additionalDissolveDelaySeconds, }: {
        neuronId: NeuronId;
        additionalDissolveDelaySeconds: number;
    }) => Promise<void>;
    /**
     * Start dissolving process of a neuron
     *
     * @throws {@link GovernanceError}
     */
    startDissolving: (neuronId: NeuronId) => Promise<void>;
    /**
     * Stop dissolving process of a neuron
     *
     * @throws {@link GovernanceError}
     */
    stopDissolving: (neuronId: NeuronId) => Promise<void>;
    /**
     * Neuron joins the community fund
     *
     * @throws {@link GovernanceError}
     */
    joinCommunityFund: (neuronId: NeuronId) => Promise<void>;
    /**
     * Merge two neurons
     *
     * @throws {@link GovernanceError}
     */
    mergeNeurons: (request: {
        sourceNeuronId: NeuronId;
        targetNeuronId: NeuronId;
    }) => Promise<void>;
    /**
     * Splits a neuron creating a new one
     *
     * @returns newNeuronId
     * @throws {@link GovernanceError}
     */
    splitNeuron: ({ neuronId, amount, }: {
        neuronId: NeuronId;
        amount: ICP;
    }) => Promise<NeuronId>;
    /**
     * Returns single proposal info
     *
     * If `certified` is true (default), the request is fetched as an update call, otherwise
     * it is fetched using a query call.
     */
    getProposal: ({ proposalId, certified, }: {
        proposalId: bigint;
        certified?: boolean | undefined;
    }) => Promise<ProposalInfo | undefined>;
    /**
     * Create new proposal
     *
     * @throws {@link GovernanceError}
     */
    makeProposal: (request: MakeProposalRequest) => Promise<void>;
    /**
     *
     * Registers vote for a proposal from the neuron passed.
     *
     * @throws {@link GovernanceError}
     */
    registerVote: ({ neuronId, vote, proposalId, }: {
        neuronId: NeuronId;
        vote: Vote;
        proposalId: ProposalId;
    }) => Promise<void>;
    /**
     * Edit neuron followees per topic
     *
     * @throws {@link GovernanceError}
     */
    setFollowees: (followRequest: FollowRequest) => Promise<void>;
    /**
     * Disburse neuron on Account
     *
     * @throws {@link GovernanceError}
     * @throws {@link InvalidAccountIDError}
     */
    disburse: ({ neuronId, toAccountId, amount, }: {
        neuronId: NeuronId;
        toAccountId?: string | undefined;
        amount?: bigint | undefined;
    }) => Promise<void>;
    /**
     * Merge Maturity of a neuron
     *
     * @throws {@link GovernanceError}
     * @throws {@link InvalidPercentageError}
     *
     */
    mergeMaturity: ({ neuronId, percentageToMerge, }: {
        neuronId: NeuronId;
        percentageToMerge: number;
    }) => Promise<void>;
    /**
     * Merge Maturity of a neuron
     *
     * @throws {@link GovernanceError}
     * @throws {@link InvalidPercentageError}
     *
     */
    spawnNeuron: ({ neuronId, percentageToSpawn, newController, nonce, }: {
        neuronId: NeuronId;
        percentageToSpawn?: number | undefined;
        newController?: Principal | undefined;
        nonce?: bigint | undefined;
    }) => Promise<bigint>;
    /**
     * Add hotkey to neuron
     *
     * @throws {@link GovernanceError}
     */
    addHotkey: ({ neuronId, principal, }: {
        neuronId: NeuronId;
        principal: Principal;
    }) => Promise<void>;
    /**
     * Remove hotkey to neuron
     *
     * @throws {@link GovernanceError}
     */
    removeHotkey: ({ neuronId, principal, }: {
        neuronId: NeuronId;
        principal: Principal;
    }) => Promise<void>;
    /**
     * Gets the NeuronID of a newly created neuron.
     */
    claimOrRefreshNeuronFromAccount: ({ memo, controller, }: {
        memo: bigint;
        controller?: Principal | undefined;
    }) => Promise<NeuronId | undefined>;
    /**
     * Refreshes neuron and returns neuronId when successful
     * Uses query call only.
     *
     * @throws {@link UnrecognizedTypeError}
     */
    claimOrRefreshNeuron: (request: ClaimOrRefreshNeuronRequest) => Promise<NeuronId | undefined>;
    private buildNeuronStakeSubAccount;
    private getGovernanceService;
    /**
     * Return the data of the neuron provided as id.
     */
    getNeuron: ({ certified, neuronId, }: {
        certified: boolean;
        neuronId: NeuronId;
    }) => Promise<NeuronInfo | undefined>;
    private listNeuronsHardwareWallet;
    private manageNeuronUpdateCall;
    private addHotkeyHardwareWallet;
    private removeHotkeyHardwareWallet;
    private increaseDissolveDelayHardwareWallet;
    private startDissolvingHardwareWallet;
    private stopDissolvingHardwareWallet;
    private disburseHardwareWallet;
    private mergeMaturityHardwareWallet;
    private spawnHardwareWallet;
    private mergeNeuronsHardwareWallet;
}
